@RestController
@RequestMapping("/kafka/admin")
@Slf4j
public class KafkaOffsetAdminController {

    private final ConsumerFactory<String, String> consumerFactory;

    public KafkaOffsetAdminController(ConsumerFactory<String, String> consumerFactory) {
        this.consumerFactory = consumerFactory;
    }

    // ==================== GET OPERATIONS ====================

    // Get current committed offsets
    @GetMapping("/offsets/{consumerGroup}/{topic}")
    public ResponseEntity<Map<String, Object>> getOffsets(
            @PathVariable String consumerGroup,
            @PathVariable String topic) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            List<TopicPartition> partitions = getPartitions(consumer, topic);

            List<Map<String, Object>> partitionOffsets = new ArrayList<>();

            for (TopicPartition tp : partitions) {
                OffsetAndMetadata committed = consumer.committed(tp);
                partitionOffsets.add(Map.of(
                    "partition", tp.partition(),
                    "committedOffset", committed != null ? committed.offset() : -1
                ));
            }

            partitionOffsets.sort(Comparator.comparing(m -> (Integer) m.get("partition")));

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "partitions", partitionOffsets
            ));

        } catch (Exception e) {
            log.error("Failed to get offsets", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // Get consumer lag
    @GetMapping("/lag/{consumerGroup}/{topic}")
    public ResponseEntity<Map<String, Object>> getLag(
            @PathVariable String consumerGroup,
            @PathVariable String topic) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            List<TopicPartition> partitions = getPartitions(consumer, topic);
            consumer.assign(partitions);

            Map<TopicPartition, Long> endOffsets = consumer.endOffsets(partitions);

            List<Map<String, Object>> lagInfo = new ArrayList<>();

            for (TopicPartition tp : partitions) {
                OffsetAndMetadata committed = consumer.committed(tp);
                long committedOffset = committed != null ? committed.offset() : 0;
                long endOffset = endOffsets.get(tp);

                lagInfo.add(Map.of(
                    "partition", tp.partition(),
                    "committedOffset", committedOffset,
                    "endOffset", endOffset,
                    "lag", endOffset - committedOffset
                ));
            }

            lagInfo.sort(Comparator.comparing(m -> (Integer) m.get("partition")));

            long totalLag = lagInfo.stream()
                .mapToLong(m -> (Long) m.get("lag"))
                .sum();

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "totalLag", totalLag,
                "partitions", lagInfo
            ));

        } catch (Exception e) {
            log.error("Failed to get lag", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // Get offset range info for all partitions
    @GetMapping("/offsets/{consumerGroup}/{topic}/range")
    public ResponseEntity<Map<String, Object>> getOffsetRange(
            @PathVariable String consumerGroup,
            @PathVariable String topic) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            List<TopicPartition> partitions = getPartitions(consumer, topic);
            consumer.assign(partitions);

            Map<TopicPartition, Long> beginningOffsets = consumer.beginningOffsets(partitions);
            Map<TopicPartition, Long> endOffsets = consumer.endOffsets(partitions);

            List<Map<String, Object>> partitionInfo = new ArrayList<>();

            for (TopicPartition tp : partitions) {
                OffsetAndMetadata committed = consumer.committed(tp);

                partitionInfo.add(Map.of(
                    "partition", tp.partition(),
                    "earliest", beginningOffsets.get(tp),
                    "latest", endOffsets.get(tp),
                    "committed", committed != null ? committed.offset() : -1,
                    "messageCount", endOffsets.get(tp) - beginningOffsets.get(tp)
                ));
            }

            partitionInfo.sort(Comparator.comparing(m -> (Integer) m.get("partition")));

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "partitions", partitionInfo
            ));

        } catch (Exception e) {
            log.error("Failed to get offset range", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // ==================== REWIND / FAST FORWARD ====================

    // REWIND - Reset to beginning (earliest) of each partition
    @PostMapping("/offsets/{consumerGroup}/{topic}/rewind")
    public ResponseEntity<Map<String, Object>> rewind(
            @PathVariable String consumerGroup,
            @PathVariable String topic) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            List<TopicPartition> partitions = getPartitions(consumer, topic);
            consumer.assign(partitions);

            Map<TopicPartition, Long> earliestOffsets = consumer.beginningOffsets(partitions);

            Map<TopicPartition, OffsetAndMetadata> offsetsToCommit = earliestOffsets.entrySet().stream()
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    e -> new OffsetAndMetadata(e.getValue())
                ));

            consumer.commitSync(offsetsToCommit);

            log.info("Rewound consumer group {} topic {} to earliest offsets", consumerGroup, topic);

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "action", "rewind",
                "offsets", formatOffsets(earliestOffsets),
                "status", "success"
            ));

        } catch (Exception e) {
            log.error("Failed to rewind", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // FAST FORWARD - Reset to end (latest) of each partition
    @PostMapping("/offsets/{consumerGroup}/{topic}/fast-forward")
    public ResponseEntity<Map<String, Object>> fastForward(
            @PathVariable String consumerGroup,
            @PathVariable String topic) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            List<TopicPartition> partitions = getPartitions(consumer, topic);
            consumer.assign(partitions);

            Map<TopicPartition, Long> latestOffsets = consumer.endOffsets(partitions);

            Map<TopicPartition, OffsetAndMetadata> offsetsToCommit = latestOffsets.entrySet().stream()
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    e -> new OffsetAndMetadata(e.getValue())
                ));

            consumer.commitSync(offsetsToCommit);

            log.info("Fast forwarded consumer group {} topic {} to latest offsets", consumerGroup, topic);

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "action", "fast-forward",
                "offsets", formatOffsets(latestOffsets),
                "status", "success"
            ));

        } catch (Exception e) {
            log.error("Failed to fast forward", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // ==================== SPECIFIC OFFSET OPERATIONS ====================

    // Reset single partition to specific offset
    @PostMapping("/offsets/{consumerGroup}/{topic}/{partition}/{offset}")
    public ResponseEntity<Map<String, Object>> resetOffset(
            @PathVariable String consumerGroup,
            @PathVariable String topic,
            @PathVariable int partition,
            @PathVariable long offset) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            TopicPartition tp = new TopicPartition(topic, partition);

            consumer.assign(Collections.singleton(tp));
            consumer.seek(tp, offset);
            consumer.commitSync(Map.of(tp, new OffsetAndMetadata(offset)));

            log.info("Reset offset for group {} topic {} partition {} to {}",
                consumerGroup, topic, partition, offset);

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "partition", partition,
                "newOffset", offset,
                "status", "success"
            ));

        } catch (Exception e) {
            log.error("Failed to reset offset", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // Reset multiple partitions with specific offsets
    @PostMapping("/offsets/{consumerGroup}/{topic}")
    public ResponseEntity<Map<String, Object>> resetOffsets(
            @PathVariable String consumerGroup,
            @PathVariable String topic,
            @RequestBody List<PartitionOffsetRequest> requests) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            List<TopicPartition> partitions = requests.stream()
                .map(r -> new TopicPartition(topic, r.getPartition()))
                .collect(Collectors.toList());

            consumer.assign(partitions);

            Map<TopicPartition, OffsetAndMetadata> offsetsToCommit = new HashMap<>();

            for (PartitionOffsetRequest request : requests) {
                TopicPartition tp = new TopicPartition(topic, request.getPartition());
                consumer.seek(tp, request.getOffset());
                offsetsToCommit.put(tp, new OffsetAndMetadata(request.getOffset()));
            }

            consumer.commitSync(offsetsToCommit);

            log.info("Reset offsets for group {} topic {}: {}", consumerGroup, topic, requests);

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "partitionsReset", requests,
                "status", "success"
            ));

        } catch (Exception e) {
            log.error("Failed to reset offsets", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // ==================== TIMESTAMP BASED RESET ====================

    // Reset all partitions to timestamp
    @PostMapping("/offsets/{consumerGroup}/{topic}/timestamp/{timestamp}")
    public ResponseEntity<Map<String, Object>> resetToTimestamp(
            @PathVariable String consumerGroup,
            @PathVariable String topic,
            @PathVariable long timestamp) {

        try (Consumer<String, String> consumer = createConsumer(consumerGroup)) {

            List<TopicPartition> partitions = getPartitions(consumer, topic);
            consumer.assign(partitions);

            Map<TopicPartition, Long> timestampQuery = partitions.stream()
                .collect(Collectors.toMap(tp -> tp, tp -> timestamp));

            Map<TopicPartition, OffsetAndTimestamp> offsetsForTimestamp =
                consumer.offsetsForTimes(timestampQuery);

            Map<TopicPartition, OffsetAndMetadata> offsetsToCommit = new HashMap<>();
            List<Map<String, Object>> resetPartitions = new ArrayList<>();

            // Get end offsets for partitions where timestamp not found
            Map<TopicPartition, Long> endOffsets = consumer.endOffsets(partitions);

            for (TopicPartition tp : partitions) {
                OffsetAndTimestamp offsetAndTimestamp = offsetsForTimestamp.get(tp);

                long targetOffset;
                String note = null;

                if (offsetAndTimestamp != null) {
                    targetOffset = offsetAndTimestamp.offset();
                } else {
                    targetOffset = endOffsets.get(tp);
                    note = "No offset for timestamp, using end offset";
                }

                consumer.seek(tp, targetOffset);
                offsetsToCommit.put(tp, new OffsetAndMetadata(targetOffset));

                Map<String, Object> partitionResult = new HashMap<>();
                partitionResult.put("partition", tp.partition());
                partitionResult.put("newOffset", targetOffset);
                if (note != null) {
                    partitionResult.put("note", note);
                }
                resetPartitions.add(partitionResult);
            }

            consumer.commitSync(offsetsToCommit);

            resetPartitions.sort(Comparator.comparing(m -> (Integer) m.get("partition")));

            log.info("Reset all partitions to timestamp {} for group {} topic {}",
                timestamp, consumerGroup, topic);

            return ResponseEntity.ok(Map.of(
                "consumerGroup", consumerGroup,
                "topic", topic,
                "action", "timestamp",
                "requestedTimestamp", timestamp,
                "partitionsReset", resetPartitions,
                "status", "success"
            ));

        } catch (Exception e) {
            log.error("Failed to reset to timestamp", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    // ==================== HELPER METHODS ====================

    private List<TopicPartition> getPartitions(Consumer<String, String> consumer, String topic) {
        return consumer.partitionsFor(topic).stream()
            .map(p -> new TopicPartition(topic, p.partition()))
            .collect(Collectors.toList());
    }

    private List<Map<String, Object>> formatOffsets(Map<TopicPartition, Long> offsets) {
        return offsets.entrySet().stream()
            .map(e -> Map.<String, Object>of(
                "partition", e.getKey().partition(),
                "offset", e.getValue()
            ))
            .sorted(Comparator.comparing(m -> (Integer) m.get("partition")))
            .collect(Collectors.toList());
    }

    private Consumer<String, String> createConsumer(String consumerGroup) {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,
            consumerFactory.getConfigurationProperties().get(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG));
        props.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroup);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);

        return new KafkaConsumer<>(props);
    }
}
